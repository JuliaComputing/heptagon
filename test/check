#!/usr/bin/env -S ocaml str.cma unix.cma

let checkdir = "_check_builds"

(* script de test *)

let compilo = ref "../../heptc"
let coption = ref "-O"

(* compilateurs utilises pour les tests de gen. de code *)

let mlc = "mlc"
let ocamlc = "ocamlc"
let javac = "javac"
let lustrec = "lustre"
let cc = "gcc -std=c99 -I../../../lib/c -I../t1_c"
let vhdlc = "vhdlc"

(* par defaut : pas de test de generation de code *)

let tomato = ref false
let memalloc = ref false
let ocaml = ref false
let java = ref false
let lustre = ref false
let c = ref false
let minils = ref false
let vhdl = ref false

let verbose = ref false

let printf = Printf.printf
let sprintf = Printf.sprintf

let process_lines in_ch process =
  let rec read_line n =
    try
      process n (input_line in_ch);
      read_line (n + 1);
    with End_of_file -> ()
  in read_line 1

type file_info = {
  mutable assert_node : string option;
  mutable main_node : bool;
}

let check_re = Str.regexp ".*CHECK[ \\t]+\\([^ *]\\)"
let main_re = Str.regexp ".*node[ \\t]+main([ \\t]*)"

let get_file_info filename =
  let info = { assert_node = None; main_node = false } in
  let process_line _ s =
    if Str.string_match check_re s 0
    then info.assert_node <- Some (Str.matched_group 1 s);
    if Str.string_match main_re s 0
    then info.main_node <- true
  in
  process_lines (open_in filename) process_line;
  info

let compile filename testbad =
  let info = get_file_info filename in
  let args_comp = String.concat " " (List.filter_map Fun.id [
      Option.map (fun s -> "-assert " ^ s) info.assert_node;
      if !verbose then Some "-v" else None;
      if info.main_node then Some "-s main" else None;
    ])
  in
  let logfile =
    if !verbose then
      " >" ^ Filename.(remove_extension (basename filename)) ^ ".log"
    else if testbad then " >/dev/null"
    else ""
  in
  let commandline = sprintf "%s %s -I good %s %s%s 2>&1"
                            !compilo !coption args_comp filename logfile
  in
  if !verbose then printf "Compile: %s\n%!" commandline;
  (match Unix.system commandline with
   | Unix.WEXITED rc -> rc = 0
   | Unix.WSIGNALED s | Unix.WSTOPPED s -> false)

let dir_exists path =
  match Unix.stat path with
  | Unix.{ st_kind = S_DIR; _ } -> true
  | _ -> failwith (sprintf "%s is not a directory" path)
  | exception (Unix.Unix_error (Unix.ENOENT, _, _)) -> false

let try_finalize f x finally y =
  let res = try f x with exn -> finally y; raise exn in
  finally y;
  res

let indir path f =
  let pwd = Unix.getcwd () in
  Unix.chdir path;
  try_finalize f () Unix.chdir pwd

let files_in path ext =
  let d = Unix.opendir path in
  let rec read_files acc =
    match Unix.readdir d with
    | f when Filename.extension f = ext ->
        read_files (Filename.concat path f :: acc)
    | _ -> read_files acc
    | exception End_of_file -> List.sort String.compare acc
  in
  try_finalize read_files [] Unix.closedir d

let score = ref 0
let max = ref 0

let test_bad f =
  if not !verbose then printf ".%!";
  incr max;
  if compile f true then
    printf "\nERROR on \"%s\" (should fail to compile)\n" f
  else incr score

exception Echec of string

let system_ok ~err commandline =
  if !verbose then printf "Running: %s\n%!" commandline;
  let ok =
    (match Unix.system commandline with
     | Unix.WEXITED rc -> rc = 0
     | Unix.WSIGNALED s | Unix.WSTOPPED s -> false)
  in
  if not ok then raise (Echec err)

let test_c eptpath base_f () =
  List.iter (fun f ->
    system_ok ~err:"C compilation failed."
      (sprintf "%s -c %s > /dev/null 2>&1" cc f)) (files_in "." ".c");
  let { assert_node; main_node } =
      get_file_info (Filename.concat eptpath (base_f ^ ".ept"))
  in
  if assert_node <> None || main_node then begin
    system_ok ~err:"Link failure." (sprintf "%s *.o -o %s 2>&1" cc base_f);
    match assert_node with
    | None -> ()
    | Some step_count ->
        system_ok ~err:"Run-time assertion failure."
                  (sprintf "%s %s >/dev/null 2>&1" base_f step_count)
  end

let test_good f =
  if not !verbose then printf ".%!";
  incr max;
  try
    let base_f = Filename.(remove_extension (basename f)) in
    if not (compile f false) then raise (Echec "Compilation failed.");

    (* Compil. minils ? *)
    if !minils then
      system_ok ~err:"Compilation to Minils failed."
                (sprintf "%s %s.mls > /dev/null 2>&1" mlc base_f);

    (* Compil. java ? *)
    if !java then
      indir ("java/" ^ String.capitalize_ascii base_f) (fun () ->
        system_ok ~err:"Compilation to Java failed."
          (sprintf "%s -cp ../../../../lib/java:../ *.java > /dev/null" javac));

    (* Compil. caml ? *)
    if !ocaml then
      system_ok ~err:"Compilation to Caml failed."
                (sprintf "%s -c %s.ml > /dev/null" ocamlc base_f);

    (* Compil. c ? *)
    if !c then indir (base_f ^ "_c") (test_c "../../good" base_f);

    (* Compil. VHDL ? *)
    if !vhdl then indir (base_f ^ "_vhdl") (fun () ->
    List.iter (fun vhdl_file ->
      system_ok ~err:"VHDL compilation failed."
        (sprintf "%s -a %s && %s -e %s > /dev/null 2>&1"
                 vhdlc vhdl_file vhdlc vhdl_file)) (files_in "." ".vhd"));

    incr score
  with Echec msg ->
    printf "\nERROR on \"%s\" (should compile):\n%s\n%!" f msg

let launch_check () =
  if not (dir_exists checkdir) then Unix.mkdir checkdir 0o777;
  Unix.chdir checkdir;

  (* les mauvais *)
  printf "Test bads\n";
  List.iter test_bad (files_in "../bad" ".ept");

  printf "\nTest goods\n%!";
  List.iter test_good (files_in "../good" ".ept");

  printf "\nTest: %d/%d : %d%%\n" !score !max (100 * !score / !max)

let activate_clean () =
  ignore (Unix.system (sprintf "rm -r %s" checkdir));
  exit 0

let activate_minils () =
  minils := true

let activate_java () =
  java := true;
  coption := !coption ^ " -target java"

let activate_caml () =
  ocaml := true;
  coption := !coption ^ " -target caml"

let activate_vhdl () =
  vhdl := true;
  coption := !coption ^ " -target vhdl"

let activate_c () =
  c := true;
  coption := !coption ^ " -target c"

let activate_tomato () =
  tomato := true;
  coption := !coption ^ " -tomato"

let activate_memalloc () =
  memalloc := true;
  coption := !coption ^ " -memalloc"

let activate_all () =
  activate_tomato ();
  activate_memalloc ();
  activate_java ();
  activate_c ()

let activate_boolean () =
  coption := !coption ^ " -bool"

let activate_deadcode () =
  coption := !coption ^ " -deadcode"

let _ = Arg.(parse [
  "-clean", Unit activate_clean, " clean build dir";
  "-java", Unit activate_java, " test of code generation (java code)";
  "-caml", Unit activate_caml, " test of code generation (caml code)";
  "-lustre", Set lustre, " test of code generation (lustre code)";
  "-mls", Unit activate_minils, " test of code generation (minils)";
  "-vhdl", Unit activate_vhdl, " test of code generation (vhdl)";
  "-bool", Unit activate_boolean, " test of boolean translation";
  "-deadcode", Unit activate_deadcode, " test of deadcode removal";
  "-tomato", Unit activate_tomato, " test of automata minimization";
  "-memalloc", Unit activate_memalloc, " test of memory allocation";
  "-c", Unit activate_c, " test of code generation (c code)";
  "-all", Unit activate_all, " test all";
  "-v", Set verbose, " verbose";
  ]
  (fun s -> coption := !coption ^ " " ^ s)
  (sprintf "usage : %s <options> <compilo>" (Filename.basename Sys.argv.(0))))

let _ = launch_check ()

